use alloc::string::String;
use alloc::sync::Arc;

use crate::arch::api::ArchPageTableAccess;
use crate::container::{CONTAINER_TABLE, Container, ContainerError, ContainerStatus};
use crate::fs::VfsPath;
use crate::loader::linux::{self, LinuxLoadError};
use crate::process::{PROCESS_TABLE, ProcessError, ProcessId};
use crate::thread::{SCHEDULER, SpawnError};

#[derive(Debug)]
pub enum ContainerStartError {
    Container(ContainerError),
    Process(ProcessError),
    Loader(LinuxLoadError),
    Spawn(SpawnError),
    MissingProcessSpec,
    MissingEntrypoint,
    InvalidCwd(crate::fs::VfsError),
}

impl From<ContainerError> for ContainerStartError {
    fn from(err: ContainerError) -> Self {
        Self::Container(err)
    }
}

impl From<ProcessError> for ContainerStartError {
    fn from(err: ProcessError) -> Self {
        Self::Process(err)
    }
}

impl From<LinuxLoadError> for ContainerStartError {
    fn from(err: LinuxLoadError) -> Self {
        Self::Loader(err)
    }
}

impl From<SpawnError> for ContainerStartError {
    fn from(err: SpawnError) -> Self {
        Self::Spawn(err)
    }
}

pub fn start_container_by_id(id: &str) -> Result<ProcessId, ContainerStartError> {
    let container = CONTAINER_TABLE.get(id).ok_or(ContainerError::NotFound)?;
    start_container(container)
}

pub fn start_container(container: Arc<Container>) -> Result<ProcessId, ContainerStartError> {
    let state = container.state();
    if state.status != ContainerStatus::Created {
        return Err(ContainerStartError::Container(ContainerError::InvalidState));
    }

    let process_spec = container
        .spec()
        .process()
        .as_ref()
        .ok_or(ContainerStartError::MissingProcessSpec)?;
    let args = process_spec
        .args()
        .as_ref()
        .ok_or(ContainerStartError::MissingEntrypoint)?;
    let entry = args
        .first()
        .map(String::as_str)
        .ok_or(ContainerStartError::MissingEntrypoint)?;
    let argv_refs: alloc::vec::Vec<&str> = args.iter().map(String::as_str).collect();
    let envp_refs: alloc::vec::Vec<&str> = process_spec
        .env()
        .as_ref()
        .map(|env| env.iter().map(String::as_str).collect())
        .unwrap_or_default();

    let cwd_raw = process_spec.cwd();
    let cwd = parse_cwd(cwd_raw)?;

    let pid = PROCESS_TABLE.create_user_process(
        "container-init",
        crate::process::ProcessDomain::Container(container.clone()),
    )?;
    let process = PROCESS_TABLE
        .process_handle(pid)
        .map_err(ContainerStartError::from)?;
    process.set_cwd(cwd);

    let program = linux::load_elf(pid, entry)?;
    let auxv = linux::build_auxv(&program, crate::mem::addr::PageSize::SIZE_4K.bytes());
    let stack_top =
        <crate::arch::Arch as crate::arch::api::ArchThread>::user_stack_top(&program.user_stack);
    let stack_pointer = PROCESS_TABLE
        .address_space(pid)
        .ok_or(ContainerStartError::Process(ProcessError::NotFound))?
        .with_page_table(|table, _| {
            linux::initialise_stack_with_args_in_table(
                table, stack_top, &argv_refs, &envp_refs, &auxv,
            )
        })
        .map_err(|err| ContainerStartError::Loader(LinuxLoadError::from(err)))?;
    if let Ok(process) = PROCESS_TABLE.process_handle(pid) {
        process.set_brk_base(program.heap_base);
    }
    let _tid = SCHEDULER.spawn_user_thread_with_stack(
        pid,
        "container-main",
        program.entry,
        program.user_stack,
        stack_pointer,
    )?;

    container.mark_running(pid)?;
    Ok(pid)
}

fn parse_cwd(raw: &str) -> Result<VfsPath, ContainerStartError> {
    let cwd = VfsPath::parse(raw).map_err(ContainerStartError::InvalidCwd)?;
    if cwd.is_absolute() {
        return Ok(cwd);
    }
    VfsPath::root()
        .join(&cwd)
        .map_err(ContainerStartError::InvalidCwd)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::fs::Directory;
    use crate::fs::force_replace_root;
    use crate::fs::memfs::MemDirectory;
    use crate::fs::tty::global_tty;
    use crate::interrupt::{INTERRUPTS, SYSTEM_TIMER, TimerTicks};
    use crate::println;
    use crate::test::kernel_test_case;
    use crate::thread::SchedulerError;

    /// ELF fixture generated by `xtask` (via `xtask-assets`) under `target/xtask-assets`.
    const LINUX_SYSCALL_ELF: &[u8] = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/xtask-assets/linux-syscall.elf"
    ));

    #[kernel_test_case]
    fn start_container_runs_entrypoint_on_container_vfs() {
        println!("[test] start_container_runs_entrypoint_on_container_vfs");

        let _ = PROCESS_TABLE.init_kernel();
        SCHEDULER.init().expect("scheduler init");
        let started = match SCHEDULER.start() {
            Ok(()) => true,
            Err(SchedulerError::AlreadyStarted) => false,
            Err(err) => panic!("scheduler start failed: {:?}", err),
        };

        let root = MemDirectory::new();
        force_replace_root(root.clone());
        CONTAINER_TABLE.clear_for_tests();

        let bundle_dir = root.create_dir("bundle").expect("create bundle dir");
        let rootfs_dir = bundle_dir.create_dir("rootfs").expect("create rootfs dir");
        let bin = rootfs_dir.create_file("demo").expect("create demo");
        let _ = bin.write_at(0, LINUX_SYSCALL_ELF).expect("write demo");
        let msg = rootfs_dir.create_file("msg.txt").expect("create msg.txt");
        let _ = msg.write_at(0, b"FILE\n").expect("write msg.txt");

        let config = bundle_dir
            .create_file("config.json")
            .expect("create config");
        config
            .write_at(
                0,
                br#"{"ociVersion":"1.0.2","root":{"path":"rootfs"},"process":{"cwd":"/","args":["/demo"],"user":{"uid":0,"gid":0}}}"#,
            )
            .expect("write config");

        let tty = global_tty();
        tty.clear_output();
        tty.push_input(b"IN\n");

        CONTAINER_TABLE
            .create("demo", "/bundle")
            .expect("create container");
        let pid = start_container_by_id("demo").expect("start container");
        wait_for_exit(pid);

        let output = tty.drain_output();
        assert_eq!(output, b"IN\nFILE\n");

        if started {
            SCHEDULER.shutdown();
            SYSTEM_TIMER
                .start_periodic(TimerTicks::new(10_000_000))
                .expect("failed to restart system timer after container test");
            INTERRUPTS.enable();
        }
    }

    fn wait_for_exit(pid: ProcessId) {
        while PROCESS_TABLE
            .thread_count(pid)
            .map(|count| count > 0)
            .unwrap_or(false)
        {
            #[cfg(target_arch = "x86_64")]
            crate::arch::x86_64::halt();
            #[cfg(not(target_arch = "x86_64"))]
            core::hint::spin_loop();
        }
    }
}
