//! Minimal launcher for Linux ELF binaries invoked via the shell.

use alloc::string::{String, ToString};

use crate::arch::api::ArchPageTableAccess;
use crate::fs::{Path, VfsError};
use crate::interrupt::INTERRUPTS;
use crate::loader::linux::{self, LinuxLoadError};
use crate::process::fs as proc_fs;
use crate::process::{PROCESS_TABLE, ProcessError, ProcessId};
use crate::thread::{SCHEDULER, SpawnError};

/// Errors surfaced while launching or supervising a Linux guest process.
#[derive(Debug)]
pub enum RunError {
    Path(VfsError),
    Process(ProcessError),
    Loader(LinuxLoadError),
    Spawn(SpawnError),
}

impl From<VfsError> for RunError {
    fn from(err: VfsError) -> Self {
        Self::Path(err)
    }
}

impl From<ProcessError> for RunError {
    fn from(err: ProcessError) -> Self {
        Self::Process(err)
    }
}

impl From<LinuxLoadError> for RunError {
    fn from(err: LinuxLoadError) -> Self {
        Self::Loader(err)
    }
}

impl From<SpawnError> for RunError {
    fn from(err: SpawnError) -> Self {
        Self::Spawn(err)
    }
}

/// Launch a Linux ELF image as a new process, wait until all of its threads finish, and return.
///
/// The loader expects a Linux ELF64 image (static/PIE) and rewrites `syscall` instructions to
/// `int 0x80` to reuse the existing trap vector. Standard file descriptors (0/1/2) are backed
/// by the global tty, and other descriptors use the per-process VFS/FdTable.
pub fn run_and_wait(origin_pid: ProcessId, raw_path: &str) -> Result<(), RunError> {
    let abs = absolute_path(origin_pid, raw_path)?;
    crate::println!(
        "[linux] launch {abs} (ELF64 static/PIE; no dynamic linking yet; limited syscalls supported)"
    );
    let pid = launch_process(&abs)?;
    wait_for_exit(pid);
    Ok(())
}

fn launch_process(path: &str) -> Result<ProcessId, RunError> {
    let pid = PROCESS_TABLE
        .create_user_process("linux-proc", crate::process::ProcessDomain::HostLinux)?;

    let program = linux::load_elf(pid, path)?;
    if let Ok(process) = PROCESS_TABLE.process_handle(pid) {
        process.set_brk_base(program.heap_base);
    }
    let argv_refs = [path];
    let envp_refs: [&str; 0] = [];
    let auxv = linux::build_auxv(&program, crate::mem::addr::PageSize::SIZE_4K.bytes());
    let stack_top =
        <crate::arch::Arch as crate::arch::api::ArchThread>::user_stack_top(&program.user_stack);
    let stack_pointer = PROCESS_TABLE
        .address_space(pid)
        .ok_or(RunError::Process(ProcessError::NotFound))?
        .with_page_table(|table, _| {
            linux::initialise_stack_with_args_in_table(
                table, stack_top, &argv_refs, &envp_refs, &auxv,
            )
        })
        .map_err(|err| RunError::Loader(LinuxLoadError::from(err)))?;
    let _tid = SCHEDULER.spawn_user_thread_with_stack(
        pid,
        "linux-main",
        program.entry,
        program.user_stack,
        stack_pointer,
    )?;

    Ok(pid)
}

fn wait_for_exit(pid: ProcessId) {
    while PROCESS_TABLE
        .thread_count(pid)
        .map(|count| count > 0)
        .unwrap_or(false)
    {
        // Ensure interrupts are enabled so HALT can resume.
        INTERRUPTS.enable();
        #[cfg(target_arch = "x86_64")]
        crate::arch::x86_64::halt();
        #[cfg(not(target_arch = "x86_64"))]
        core::hint::spin_loop();
    }
}

fn absolute_path(origin_pid: ProcessId, raw: &str) -> Result<String, RunError> {
    let cwd = proc_fs::cwd(origin_pid)?;
    let abs = Path::resolve(raw, &cwd)?;
    Ok(abs.to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::arch::api::ArchThread;
    use crate::arch::x86_64::{arm_user_pf_frame_check, user_pf_frame_check_passed};
    use crate::device::tty::global_tty;
    use crate::fs::DirNode;
    use crate::fs::force_replace_root;
    use crate::fs::memfs::MemDirectory;
    use crate::interrupt::{INTERRUPTS, SYSTEM_TIMER, TimerTicks};
    use crate::loader::linux;
    use crate::net::runtime::{self, TestNetworkDevice};
    use crate::net::smoltcp::{SmoltcpStack, to_smoltcp_ipv4};
    use crate::net::{IpAddr, Ipv4Addr, NetCidr};
    use crate::println;
    use crate::process::PROCESS_TABLE;
    use crate::test::kernel_test_case;
    use crate::thread::{SCHEDULER, SchedulerError};
    use crate::util::spinlock::SpinLock;
    use core::sync::atomic::{AtomicBool, Ordering};
    use smoltcp::socket::tcp::{Socket as RawTcpSocket, SocketBuffer as RawTcpSocketBuffer};
    use smoltcp::wire::{IpAddress, IpEndpoint};
    /// ELF fixture generated by `xtask` (via `xtask-assets`) under `target/xtask-assets`.
    const LINUX_SYSCALL_ELF: &[u8] = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/xtask-assets/linux-syscall.elf"
    ));
    const LINUX_SYSCALL_ADV_ELF: &[u8] = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/xtask-assets/linux-syscall-adv.elf"
    ));
    const LINUX_SYSCALL_CHILD_ELF: &[u8] = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/xtask-assets/linux-syscall-child.elf"
    ));
    const LINUX_SYSCALL_NET_ELF: &[u8] = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/xtask-assets/linux-syscall-net.elf"
    ));
    const LINUX_PAGE_FAULT_ELF: &[u8] = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/xtask-assets/linux-page-fault.elf"
    ));
    const LINUX_PAGE_FAULT_ADDR: u64 = 0xdeadbeef000;
    const NET_SERVER_IP: Ipv4Addr = Ipv4Addr::new(10, 0, 2, 15);
    const NET_CLIENT_IP: Ipv4Addr = Ipv4Addr::new(10, 0, 2, 16);
    const NET_PORT: u16 = 12_346;
    static NET_CLIENT_DEVICE: SpinLock<Option<TestNetworkDevice>> = SpinLock::new(None);
    static NET_CLIENT_DONE: AtomicBool = AtomicBool::new(false);
    static NET_CLIENT_OK: AtomicBool = AtomicBool::new(false);

    fn net_client_entry() -> ! {
        let device = NET_CLIENT_DEVICE
            .lock()
            .take()
            .expect("net client device missing");
        let client_addr = NetCidr::new(IpAddr::V4(NET_CLIENT_IP), 24);
        let mut client_stack = SmoltcpStack::new(device, &[client_addr]);

        let local_endpoint =
            IpEndpoint::new(IpAddress::Ipv4(to_smoltcp_ipv4(NET_CLIENT_IP)), 40_001);
        let remote_endpoint =
            IpEndpoint::new(IpAddress::Ipv4(to_smoltcp_ipv4(NET_SERVER_IP)), NET_PORT);

        let client_socket = RawTcpSocket::new(
            RawTcpSocketBuffer::new(alloc::vec![0; 4096]),
            RawTcpSocketBuffer::new(alloc::vec![0; 4096]),
        );
        let client_handle = client_stack.sockets_mut().add(client_socket);

        client_stack
            .with_context_and_sockets(|cx, sockets| {
                sockets.get_mut::<RawTcpSocket>(client_handle).connect(
                    cx,
                    remote_endpoint,
                    local_endpoint,
                )
            })
            .expect("client connect");

        let payload = b"PING";
        let mut sent = false;
        let mut received = false;
        let mut recv_buf = [0u8; 16];

        for _ in 0..200_000 {
            let _ = client_stack.poll();
            let _ = runtime::poll();
            client_stack.with_context_and_sockets(|_, sockets| {
                let socket = sockets.get_mut::<RawTcpSocket>(client_handle);
                if !sent && socket.can_send() {
                    let _ = socket.send_slice(payload);
                    sent = true;
                }
                if socket.can_recv() {
                    if let Ok(size) = socket.recv_slice(&mut recv_buf) {
                        if size >= 4 && &recv_buf[..4] == b"PONG" {
                            received = true;
                        }
                    }
                }
            });
            if received {
                break;
            }
            core::hint::spin_loop();
        }

        NET_CLIENT_OK.store(received, Ordering::Release);
        NET_CLIENT_DONE.store(true, Ordering::Release);

        loop {
            core::hint::spin_loop();
        }
    }

    #[kernel_test_case]
    fn linux_binary_reads_stdin_and_file() {
        println!("[test] linux_binary_reads_stdin_and_file");

        let _ = PROCESS_TABLE.init_kernel();
        SCHEDULER.init().expect("scheduler init");
        let started = match SCHEDULER.start() {
            Ok(()) => true,
            Err(SchedulerError::AlreadyStarted) => false,
            Err(err) => panic!("scheduler start failed: {:?}", err),
        };
        let root = MemDirectory::new();
        force_replace_root(root.clone());

        let file = root.create_file("msg.txt").expect("create msg.txt");
        let handle = file.open(crate::fs::OpenOptions::new(0)).expect("open msg");
        let _ = handle.write(b"FILE\n").expect("write msg.txt");

        let bin = root.create_file("demo").expect("create demo");
        let handle = bin.open(crate::fs::OpenOptions::new(0)).expect("open demo");
        let _ = handle.write(LINUX_SYSCALL_ELF).expect("write demo");

        let tty = global_tty();
        tty.clear_output();
        tty.push_input(b"IN\n");

        let kernel_pid = PROCESS_TABLE.kernel_process_id().expect("kernel pid");
        run_and_wait(kernel_pid, "/demo").expect("run linux demo");

        let output = tty.drain_output();
        assert_eq!(output, b"IN\nFILE\n");

        if started {
            SCHEDULER.shutdown();
            SYSTEM_TIMER
                .start_periodic(TimerTicks::new(10_000_000))
                .expect("failed to restart system timer after linux-box test");
            INTERRUPTS.enable();
        }
    }

    #[kernel_test_case]
    fn linux_binary_exercises_process_syscalls() {
        println!("[test] linux_binary_exercises_process_syscalls");

        let _ = PROCESS_TABLE.init_kernel();
        SCHEDULER.init().expect("scheduler init");
        let started = match SCHEDULER.start() {
            Ok(()) => true,
            Err(SchedulerError::AlreadyStarted) => false,
            Err(err) => panic!("scheduler start failed: {:?}", err),
        };

        let root = MemDirectory::new();
        force_replace_root(root.clone());

        let stat_file = root.create_file("stat.txt").expect("create stat.txt");
        let handle = stat_file
            .open(crate::fs::OpenOptions::new(0))
            .expect("open stat.txt");
        let _ = handle.write(b"STATDATA").expect("write stat.txt");
        let _ = root
            .create_symlink("stat-link", "stat.txt")
            .expect("create stat-link");

        let adv = root.create_file("adv").expect("create adv");
        let handle = adv.open(crate::fs::OpenOptions::new(0)).expect("open adv");
        let _ = handle.write(LINUX_SYSCALL_ADV_ELF).expect("write adv");

        let child = root.create_file("child").expect("create child");
        let handle = child
            .open(crate::fs::OpenOptions::new(0))
            .expect("open child");
        let _ = handle.write(LINUX_SYSCALL_CHILD_ELF).expect("write child");

        let tty = global_tty();
        tty.clear_output();

        let kernel_pid = PROCESS_TABLE.kernel_process_id().expect("kernel pid");
        run_and_wait(kernel_pid, "/adv").expect("run linux adv");

        let output = tty.drain_output();
        assert_eq!(
            output,
            b"WRITEV\nSTAT:OK\nLSTAT:OK\nOPENAT:OK\nFSTATAT:OK\nDENTS:OK\nIOCTL:OK\nMMAP:OK\nBRK:OK\nARCH:OK\nFORK:CHILD\nEXEC:CHILD\nWAIT:42\n"
        );

        if started {
            SCHEDULER.shutdown();
        }
    }

    #[kernel_test_case]
    fn linux_binary_accepts_tcp_connection() {
        println!("[test] linux_binary_accepts_tcp_connection");

        let _ = PROCESS_TABLE.init_kernel();
        SCHEDULER.init().expect("scheduler init");
        let started = match SCHEDULER.start() {
            Ok(()) => true,
            Err(SchedulerError::AlreadyStarted) => false,
            Err(err) => panic!("scheduler start failed: {:?}", err),
        };

        runtime::reset_for_tests();
        let (server_dev, client_dev) = TestNetworkDevice::pair();
        runtime::init_for_tests(server_dev);
        *NET_CLIENT_DEVICE.lock() = Some(client_dev);
        NET_CLIENT_DONE.store(false, Ordering::Release);
        NET_CLIENT_OK.store(false, Ordering::Release);

        let root = MemDirectory::new();
        force_replace_root(root.clone());

        let bin = root.create_file("net").expect("create net fixture");
        let handle = bin.open(crate::fs::OpenOptions::new(0)).expect("open net");
        let _ = handle.write(LINUX_SYSCALL_NET_ELF).expect("write net");

        let tty = global_tty();
        tty.clear_output();

        let pid = launch_process("/net").expect("launch net fixture");
        SCHEDULER
            .spawn_kernel_thread("net-client", net_client_entry)
            .expect("spawn net client");

        super::wait_for_exit(pid);
        while !NET_CLIENT_DONE.load(Ordering::Acquire) {
            core::hint::spin_loop();
        }
        assert!(
            NET_CLIENT_OK.load(Ordering::Acquire),
            "client did not receive PONG"
        );

        let output = tty.drain_output();
        assert_eq!(output, b"NET:OK\n");

        if started {
            SCHEDULER.shutdown();
            SYSTEM_TIMER
                .start_periodic(TimerTicks::new(10_000_000))
                .expect("failed to restart system timer after linux-box test");
            INTERRUPTS.enable();
        }
    }

    #[kernel_test_case]
    fn linux_page_fault_trap_frame_matches_cpu_frame() {
        println!("[test] linux_page_fault_trap_frame_matches_cpu_frame");

        let _ = PROCESS_TABLE.init_kernel();
        SCHEDULER.init().expect("scheduler init");
        let started = match SCHEDULER.start() {
            Ok(()) => true,
            Err(SchedulerError::AlreadyStarted) => false,
            Err(err) => panic!("scheduler start failed: {:?}", err),
        };

        let root = MemDirectory::new();
        force_replace_root(root.clone());

        let bin = root.create_file("pf").expect("create page-fault fixture");
        let handle = bin.open(crate::fs::OpenOptions::new(0)).expect("open pf");
        let _ = handle
            .write(LINUX_PAGE_FAULT_ELF)
            .expect("write page-fault fixture");

        let pid = PROCESS_TABLE
            .create_user_process("linux-proc", crate::process::ProcessDomain::HostLinux)
            .expect("create user process");
        arm_user_pf_frame_check(pid, LINUX_PAGE_FAULT_ADDR);

        let program = linux::load_elf(pid, "/pf").expect("load page-fault fixture");
        if let Ok(process) = PROCESS_TABLE.process_handle(pid) {
            process.set_brk_base(program.heap_base);
        }
        let argv_refs = ["/pf"];
        let envp_refs: [&str; 0] = [];
        let auxv = linux::build_auxv(&program, crate::mem::addr::PageSize::SIZE_4K.bytes());
        let stack_top = <crate::arch::Arch as ArchThread>::user_stack_top(&program.user_stack);
        let stack_pointer = PROCESS_TABLE
            .address_space(pid)
            .expect("user address space")
            .with_page_table(|table, _| {
                linux::initialise_stack_with_args_in_table(
                    table, stack_top, &argv_refs, &envp_refs, &auxv,
                )
            })
            .expect("init page-fault stack");
        SCHEDULER
            .spawn_user_thread_with_stack(
                pid,
                "linux-main",
                program.entry,
                program.user_stack,
                stack_pointer,
            )
            .expect("spawn page-fault thread");
        super::wait_for_exit(pid);

        assert!(
            user_pf_frame_check_passed(),
            "page-fault trap frame check did not complete"
        );

        if started {
            SCHEDULER.shutdown();
            SYSTEM_TIMER
                .start_periodic(TimerTicks::new(10_000_000))
                .expect("failed to restart system timer after page-fault test");
            INTERRUPTS.enable();
        }
    }
}
