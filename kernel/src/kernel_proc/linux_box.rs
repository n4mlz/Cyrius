//! Minimal launcher for Linux ELF binaries invoked via the shell.

use alloc::string::{String, ToString};

use crate::fs::{VfsError, VfsPath};
use crate::loader::linux::{self, LinuxLoadError};
use crate::process::fs as proc_fs;
use crate::process::{PROCESS_TABLE, ProcessError, ProcessId};
use crate::syscall::Abi;
use crate::thread::{SCHEDULER, SpawnError};

/// Errors surfaced while launching or supervising a Linux guest process.
#[derive(Debug)]
pub enum RunError {
    Path(VfsError),
    Process(ProcessError),
    Loader(LinuxLoadError),
    Spawn(SpawnError),
}

impl From<VfsError> for RunError {
    fn from(err: VfsError) -> Self {
        Self::Path(err)
    }
}

impl From<ProcessError> for RunError {
    fn from(err: ProcessError) -> Self {
        Self::Process(err)
    }
}

impl From<LinuxLoadError> for RunError {
    fn from(err: LinuxLoadError) -> Self {
        Self::Loader(err)
    }
}

impl From<SpawnError> for RunError {
    fn from(err: SpawnError) -> Self {
        Self::Spawn(err)
    }
}

/// Launch a Linux ELF image as a new process, wait until all of its threads finish, and return.
///
/// The loader expects a static, non-PIE ELF64 image and rewrites `syscall` instructions to
/// `int 0x80` to reuse the existing trap vector. Standard file descriptors (0/1/2) are backed
/// by the global tty, and other descriptors use the per-process VFS/FdTable.
pub fn run_and_wait(origin_pid: ProcessId, raw_path: &str) -> Result<(), RunError> {
    let abs = absolute_path(origin_pid, raw_path)?;
    crate::println!(
        "[linux] launch {abs} (static ELF64, no PIE or dynamic linking; limited syscalls supported)"
    );
    let pid = launch_process(&abs)?;
    wait_for_exit(pid);
    Ok(())
}

fn launch_process(path: &str) -> Result<ProcessId, RunError> {
    let pid = PROCESS_TABLE.create_user_process_with_abi("linux-proc", Abi::Linux)?;

    let program = linux::load_elf(pid, path)?;
    if let Ok(process) = PROCESS_TABLE.process_handle(pid) {
        process.set_brk_base(program.heap_base);
    }
    let _tid = SCHEDULER.spawn_user_thread_with_stack(
        pid,
        "linux-main",
        program.entry,
        program.user_stack,
        program.stack_pointer,
    )?;

    Ok(pid)
}

fn wait_for_exit(pid: ProcessId) {
    while PROCESS_TABLE
        .thread_count(pid)
        .map(|count| count > 0)
        .unwrap_or(false)
    {
        #[cfg(target_arch = "x86_64")]
        crate::arch::x86_64::halt();
        #[cfg(not(target_arch = "x86_64"))]
        core::hint::spin_loop();
    }
}

fn absolute_path(origin_pid: ProcessId, raw: &str) -> Result<String, RunError> {
    let cwd = proc_fs::cwd(origin_pid)?;
    let abs = VfsPath::resolve(raw, &cwd)?;
    Ok(abs.to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::fs::Directory;
    use crate::fs::force_replace_root;
    use crate::fs::memfs::MemDirectory;
    use crate::fs::tty::global_tty;
    use crate::interrupt::{INTERRUPTS, SYSTEM_TIMER, TimerTicks};
    use crate::println;
    use crate::process::PROCESS_TABLE;
    use crate::test::kernel_test_case;
    use crate::thread::{SCHEDULER, SchedulerError};
    /// ELF fixture generated by `xtask` (via `xtask-assets`) under `target/xtask-assets`.
    const LINUX_SYSCALL_ELF: &[u8] = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/xtask-assets/linux-syscall.elf"
    ));
    const LINUX_SYSCALL_ADV_ELF: &[u8] = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/xtask-assets/linux-syscall-adv.elf"
    ));
    const LINUX_SYSCALL_CHILD_ELF: &[u8] = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/xtask-assets/linux-syscall-child.elf"
    ));

    #[kernel_test_case]
    fn linux_binary_reads_stdin_and_file() {
        println!("[test] linux_binary_reads_stdin_and_file");

        let _ = PROCESS_TABLE.init_kernel();
        SCHEDULER.init().expect("scheduler init");
        let started = match SCHEDULER.start() {
            Ok(()) => true,
            Err(SchedulerError::AlreadyStarted) => false,
            Err(err) => panic!("scheduler start failed: {:?}", err),
        };

        let root = MemDirectory::new();
        force_replace_root(root.clone());

        let file = root.create_file("msg.txt").expect("create msg.txt");
        let _ = file.write_at(0, b"FILE\n").expect("write msg.txt");

        let bin = root.create_file("demo").expect("create demo");
        let _ = bin.write_at(0, LINUX_SYSCALL_ELF).expect("write demo");

        let tty = global_tty();
        tty.clear_output();
        tty.push_input(b"IN\n");

        let kernel_pid = PROCESS_TABLE.kernel_process_id().expect("kernel pid");
        run_and_wait(kernel_pid, "/demo").expect("run linux demo");

        let output = tty.drain_output();
        assert_eq!(output, b"IN\nFILE\n");

        if started {
            SCHEDULER.shutdown();
            SYSTEM_TIMER
                .start_periodic(TimerTicks::new(10_000_000))
                .expect("failed to restart system timer after linux-box test");
            INTERRUPTS.enable();
        }
    }

    #[kernel_test_case]
    fn linux_binary_exercises_process_syscalls() {
        println!("[test] linux_binary_exercises_process_syscalls");

        let _ = PROCESS_TABLE.init_kernel();
        SCHEDULER.init().expect("scheduler init");
        let started = match SCHEDULER.start() {
            Ok(()) => true,
            Err(SchedulerError::AlreadyStarted) => false,
            Err(err) => panic!("scheduler start failed: {:?}", err),
        };

        let root = MemDirectory::new();
        force_replace_root(root.clone());

        let stat_file = root.create_file("stat.txt").expect("create stat.txt");
        let _ = stat_file.write_at(0, b"STATDATA").expect("write stat.txt");

        let adv = root.create_file("adv").expect("create adv");
        let _ = adv.write_at(0, LINUX_SYSCALL_ADV_ELF).expect("write adv");

        let child = root.create_file("child").expect("create child");
        let _ = child
            .write_at(0, LINUX_SYSCALL_CHILD_ELF)
            .expect("write child");

        let tty = global_tty();
        tty.clear_output();

        let kernel_pid = PROCESS_TABLE.kernel_process_id().expect("kernel pid");
        run_and_wait(kernel_pid, "/adv").expect("run linux adv");

        let output = tty.drain_output();
        assert_eq!(
            output,
            b"WRITEV\nSTAT:OK\nBRK:OK\nARCH:OK\nFORK:CHILD\nEXEC:CHILD\nWAIT:42\n"
        );

        if started {
            SCHEDULER.shutdown();
        }
    }
}
