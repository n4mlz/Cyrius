//! Minimal launcher for Linux ELF binaries invoked via the shell.

use alloc::string::{String, ToString};

use crate::arch::api::ArchPageTableAccess;
use crate::fs::{Path, VfsError};
use crate::loader::linux::{self, LinuxLoadError};
use crate::process::fs as proc_fs;
use crate::process::{PROCESS_TABLE, ProcessError, ProcessId};
use crate::interrupt::INTERRUPTS;
use crate::thread::{SCHEDULER, SpawnError};

/// Errors surfaced while launching or supervising a Linux guest process.
#[derive(Debug)]
pub enum RunError {
    Path(VfsError),
    Process(ProcessError),
    Loader(LinuxLoadError),
    Spawn(SpawnError),
}

impl From<VfsError> for RunError {
    fn from(err: VfsError) -> Self {
        Self::Path(err)
    }
}

impl From<ProcessError> for RunError {
    fn from(err: ProcessError) -> Self {
        Self::Process(err)
    }
}

impl From<LinuxLoadError> for RunError {
    fn from(err: LinuxLoadError) -> Self {
        Self::Loader(err)
    }
}

impl From<SpawnError> for RunError {
    fn from(err: SpawnError) -> Self {
        Self::Spawn(err)
    }
}

/// Launch a Linux ELF image as a new process, wait until all of its threads finish, and return.
///
/// The loader expects a Linux ELF64 image (static/PIE) and rewrites `syscall` instructions to
/// `int 0x80` to reuse the existing trap vector. Standard file descriptors (0/1/2) are backed
/// by the global tty, and other descriptors use the per-process VFS/FdTable.
pub fn run_and_wait(origin_pid: ProcessId, raw_path: &str) -> Result<(), RunError> {
    let abs = absolute_path(origin_pid, raw_path)?;
    crate::println!(
        "[linux] launch {abs} (ELF64 static/PIE; no dynamic linking yet; limited syscalls supported)"
    );
    let pid = launch_process(&abs)?;
    wait_for_exit(pid);
    Ok(())
}

fn launch_process(path: &str) -> Result<ProcessId, RunError> {
    let pid = PROCESS_TABLE
        .create_user_process("linux-proc", crate::process::ProcessDomain::HostLinux)?;

    let program = linux::load_elf(pid, path)?;
    if let Ok(process) = PROCESS_TABLE.process_handle(pid) {
        process.set_brk_base(program.heap_base);
    }
    let argv_refs = [path];
    let envp_refs: [&str; 0] = [];
    let auxv = linux::build_auxv(&program, crate::mem::addr::PageSize::SIZE_4K.bytes());
    let stack_top =
        <crate::arch::Arch as crate::arch::api::ArchThread>::user_stack_top(&program.user_stack);
    let stack_pointer = PROCESS_TABLE
        .address_space(pid)
        .ok_or(RunError::Process(ProcessError::NotFound))?
        .with_page_table(|table, _| {
            linux::initialise_stack_with_args_in_table(
                table, stack_top, &argv_refs, &envp_refs, &auxv,
            )
        })
        .map_err(|err| RunError::Loader(LinuxLoadError::from(err)))?;
    let _tid = SCHEDULER.spawn_user_thread_with_stack(
        pid,
        "linux-main",
        program.entry,
        program.user_stack,
        stack_pointer,
    )?;

    Ok(pid)
}

fn wait_for_exit(pid: ProcessId) {
    while PROCESS_TABLE
        .thread_count(pid)
        .map(|count| count > 0)
        .unwrap_or(false)
    {
        // Ensure interrupts are enabled so HALT can resume.
        INTERRUPTS.enable();
        #[cfg(target_arch = "x86_64")]
        crate::arch::x86_64::halt();
        #[cfg(not(target_arch = "x86_64"))]
        core::hint::spin_loop();
    }
}

fn absolute_path(origin_pid: ProcessId, raw: &str) -> Result<String, RunError> {
    let cwd = proc_fs::cwd(origin_pid)?;
    let abs = Path::resolve(raw, &cwd)?;
    Ok(abs.to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::device::tty::global_tty;
    use crate::fs::DirNode;
    use crate::fs::force_replace_root;
    use crate::fs::memfs::MemDirectory;
    use crate::interrupt::{INTERRUPTS, SYSTEM_TIMER, TimerTicks};
    use crate::println;
    use crate::process::PROCESS_TABLE;
    use crate::test::kernel_test_case;
    use crate::thread::{SCHEDULER, SchedulerError};
    /// ELF fixture generated by `xtask` (via `xtask-assets`) under `target/xtask-assets`.
    const LINUX_SYSCALL_ELF: &[u8] = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/xtask-assets/linux-syscall.elf"
    ));
    const LINUX_SYSCALL_ADV_ELF: &[u8] = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/xtask-assets/linux-syscall-adv.elf"
    ));
    const LINUX_SYSCALL_CHILD_ELF: &[u8] = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/xtask-assets/linux-syscall-child.elf"
    ));

    #[kernel_test_case]
    fn linux_binary_reads_stdin_and_file() {
        println!("[test] linux_binary_reads_stdin_and_file");

        let _ = PROCESS_TABLE.init_kernel();
        SCHEDULER.init().expect("scheduler init");
        let started = match SCHEDULER.start() {
            Ok(()) => true,
            Err(SchedulerError::AlreadyStarted) => false,
            Err(err) => panic!("scheduler start failed: {:?}", err),
        };

        let root = MemDirectory::new();
        force_replace_root(root.clone());

        let file = root.create_file("msg.txt").expect("create msg.txt");
        let handle = file.open(crate::fs::OpenOptions::new(0)).expect("open msg");
        let _ = handle.write(b"FILE\n").expect("write msg.txt");

        let bin = root.create_file("demo").expect("create demo");
        let handle = bin.open(crate::fs::OpenOptions::new(0)).expect("open demo");
        let _ = handle.write(LINUX_SYSCALL_ELF).expect("write demo");

        let tty = global_tty();
        tty.clear_output();
        tty.push_input(b"IN\n");

        let kernel_pid = PROCESS_TABLE.kernel_process_id().expect("kernel pid");
        run_and_wait(kernel_pid, "/demo").expect("run linux demo");

        let output = tty.drain_output();
        assert_eq!(output, b"IN\nFILE\n");

        if started {
            SCHEDULER.shutdown();
            SYSTEM_TIMER
                .start_periodic(TimerTicks::new(10_000_000))
                .expect("failed to restart system timer after linux-box test");
            INTERRUPTS.enable();
        }
    }

    #[kernel_test_case]
    fn linux_binary_exercises_process_syscalls() {
        println!("[test] linux_binary_exercises_process_syscalls");

        let _ = PROCESS_TABLE.init_kernel();
        SCHEDULER.init().expect("scheduler init");
        let started = match SCHEDULER.start() {
            Ok(()) => true,
            Err(SchedulerError::AlreadyStarted) => false,
            Err(err) => panic!("scheduler start failed: {:?}", err),
        };

        let root = MemDirectory::new();
        force_replace_root(root.clone());

        let stat_file = root.create_file("stat.txt").expect("create stat.txt");
        let handle = stat_file
            .open(crate::fs::OpenOptions::new(0))
            .expect("open stat.txt");
        let _ = handle.write(b"STATDATA").expect("write stat.txt");

        let adv = root.create_file("adv").expect("create adv");
        let handle = adv.open(crate::fs::OpenOptions::new(0)).expect("open adv");
        let _ = handle.write(LINUX_SYSCALL_ADV_ELF).expect("write adv");

        let child = root.create_file("child").expect("create child");
        let handle = child
            .open(crate::fs::OpenOptions::new(0))
            .expect("open child");
        let _ = handle.write(LINUX_SYSCALL_CHILD_ELF).expect("write child");

        let tty = global_tty();
        tty.clear_output();

        let kernel_pid = PROCESS_TABLE.kernel_process_id().expect("kernel pid");
        run_and_wait(kernel_pid, "/adv").expect("run linux adv");

        let output = tty.drain_output();
        assert_eq!(
            output,
            b"WRITEV\nSTAT:OK\nIOCTL:OK\nMMAP:OK\nBRK:OK\nARCH:OK\nFORK:CHILD\nEXEC:CHILD\nWAIT:42\n"
        );

        if started {
            SCHEDULER.shutdown();
        }
    }
}
