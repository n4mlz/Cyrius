# Kernel Processes (Shell / Linux Box)

## Role and Scope
- Groups kernel-resident processes such as the interactive shell and the Linux ELF launcher.
- Lives under `kernel_proc` to keep kernel-only utilities together rather than scattering top-level modules.

## Shell
- Provides a minimal REPL for filesystem operations, a front-end to launch Linux ELF binaries via
  `linux-box run <path>`, and host container management via `oci-runtime create <id> <bundle>`.
- `oci_runtime` houses the host ABI bridge for OCI-style commands to keep shell parsing focused on
  REPL concerns.
- Tokenisation is whitespace-based; quoted strings are not supported.
- Errors bubble up from the filesystem (`VfsError`), process table (`ProcessError`), loader (`LinuxLoadError`), and thread spawning (`SpawnError`) without wrapping in an extra linux-box-specific error layer.
- Runs as a kernel thread associated with a kernel process, reusing the process CWD and FD table for all commands.
- `tar <archive>` extracts a POSIX tar file into the caller’s current working directory on the writable ramfs mount. Regular files, directories, symlinks, and hard links are supported, paths must be relative (no `..` or absolute prefixes), and checksum validation guards against malformed archives.
- Tar fixtures used by kernel tests are generated by `xtask` (via `xtask-assets`) under `target/xtask-assets`, keeping them independent of the host `mnt/` directory. `busybox.tar` is built from the `busybox:musl` OCI image via `skopeo` + `umoci` and then packaged with the Rust tar writer.

## Linux Box
- Resolves paths relative to the caller’s CWD, switches the target process ABI to Linux, loads a static ELF64, rewrites `syscall` opcodes to `int 0x80`, and spawns a user thread using the loader-prepared stack pointer.
- Surfaces errors directly from existing subsystems (process table, VFS, ELF loader, thread spawning) for transparency.
- Known constraints: only `open`/`read`/`write`/`close`/`getpid`/`exit` syscalls, static non-PIE ELF64, no dynamic linking.
- The linux-syscall test fixture binary is compiled via `xtask-assets` using the host C toolchain
  (`cc`/`gcc`/`clang`) into `target/xtask-assets/linux-syscall.elf`.
- `xtask` also runs the linux-syscall binary on the host to confirm Linux and Cyrius produce the
  same stdout for the stdin/file I/O scenario.

## Future Work
- Add richer status reporting (exit code, stdout capture) once process lifecycle management and IPC mature.
- Extend the shell parser to handle quoted paths and background execution.
