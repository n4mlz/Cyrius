# Kernel Processes (Shell / Linux Box / Web Server)

## Role and Scope
- Groups kernel-resident processes such as the interactive shell and the Linux ELF launcher.
- Lives under `kernel_proc` to keep kernel-only utilities together rather than scattering top-level modules.

## Shell
- Provides a minimal REPL for filesystem operations, a front-end to launch Linux ELF binaries via
  `linux-box run <path>`, and host container management via `oci-runtime create/start/state`.
- `oci_runtime` houses the host ABI bridge for OCI-style commands to keep shell parsing focused on
  REPL concerns.
- Tokenisation is whitespace-based; quoted strings are not supported.
- Errors bubble up from the filesystem (`VfsError`), process table (`ProcessError`), loader (`LinuxLoadError`), and thread spawning (`SpawnError`) without wrapping in an extra linux-box-specific error layer.
- Runs as a kernel thread associated with a kernel process, reusing the process CWD and FD table for all commands.
- `tar <archive>` extracts a POSIX tar file into the caller’s current working directory on the writable ramfs mount. Regular files, directories, symlinks, and hard links are supported, paths must be relative (no `..` or absolute prefixes), and checksum validation guards against malformed archives.
- Tar fixtures used by kernel tests are generated by `xtask` (via `xtask-assets`) under `target/xtask-assets`, keeping them independent of the host `mnt/` directory. `busybox.tar` is built from the `busybox:musl` OCI image via `skopeo` + `umoci` and then packaged with the Rust tar writer.

## Linux Box
- Resolves paths relative to the caller’s CWD, switches the target process ABI to Linux, loads an ELF64 image (static/PIE), rewrites `syscall` opcodes to `int 0x80`, and spawns a user thread with a SysV-style stack (argv/envp + auxv).
- Surfaces errors directly from existing subsystems (process table, VFS, ELF loader, thread spawning) for transparency.
- Known constraints: no dynamic linking yet (PIE supported) and a limited Linux syscall surface (basic process, brk, stat, and console I/O).
- The linux-syscall test fixture binary is compiled via `xtask-assets` using the host C toolchain
  (`cc`/`gcc`/`clang`) into `target/xtask-assets/linux-syscall.elf`.
- Additional syscall coverage comes from `linux-syscall-adv.elf` plus its exec target
  `linux-syscall-child.elf`, built via `xtask-assets` from `xtask-assets/fixtures`.
- `xtask` also runs the linux-syscall binary on the host to confirm Linux and Cyrius produce the
  same stdout for the stdin/file I/O scenario.

## Web Server
- `web_server` demonstrates a kernel-resident TCP service built on the smoltcp-backed TCP wrapper.
- The server is a simple echo loop bound to `0.0.0.0:12345`, mirroring the std example while staying `no_std`.
- It is spawned during scheduler initialisation alongside the shell and depends on `net::spawn_background_tasks` polling the runtime for progress.

## Future Work
- Add richer status reporting (exit code, stdout capture) once process lifecycle management and IPC mature.
- Extend the shell parser to handle quoted paths and background execution.
