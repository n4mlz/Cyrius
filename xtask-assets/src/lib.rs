use std::fs::{self, File};
use std::io::{self, Read, Write};
use std::path::{Path, PathBuf};
use std::process::Command;
use std::time::SystemTime;

#[cfg(unix)]
use std::collections::HashMap;

const OCI_IMAGE: &str = "docker://busybox:musl";
const OCI_TAG: &str = "latest";

/// Tar fixtures for kernel tests and host-mount checks.
///
/// The `busybox.tar` asset is generated by fetching an OCI image and unpacking
/// it with external tools; see `build_busybox_tar_from_oci` for dependencies.
pub struct AssetPaths {
    pub sample_with_links: PathBuf,
    pub busybox: PathBuf,
}

pub fn ensure_tar_assets(out_dir: &Path) -> io::Result<AssetPaths> {
    fs::create_dir_all(out_dir)?;

    let sample_with_links = out_dir.join("sample_with_links.tar");
    let busybox = out_dir.join("busybox.tar");

    write_if_missing(&sample_with_links, build_sample_with_links_tar)?;
    if !busybox.exists() {
        build_busybox_tar_from_oci(out_dir, &busybox)?;
    }

    Ok(AssetPaths {
        sample_with_links,
        busybox,
    })
}

pub fn ensure_linux_syscall_elf(out_dir: &Path) -> io::Result<PathBuf> {
    fs::create_dir_all(out_dir)?;
    let out_path = out_dir.join("linux-syscall.elf");

    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let src_dir = manifest_dir.join("fixtures").join("linux-syscall");
    let src = src_dir.join("main.c");
    let lib = src_dir.join("libsyscall.c");
    if !src.exists() {
        return Err(io::Error::new(
            io::ErrorKind::NotFound,
            "linux-syscall fixture missing",
        ));
    }

    if !needs_rebuild_multi(&[&src, &lib], &out_path)? {
        return Ok(out_path);
    }

    build_linux_syscall_elf(&[&src, &lib], &out_path)?;

    Ok(out_path)
}

pub fn ensure_linux_syscall_adv_elf(out_dir: &Path) -> io::Result<PathBuf> {
    fs::create_dir_all(out_dir)?;
    let out_path = out_dir.join("linux-syscall-adv.elf");

    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let src_dir = manifest_dir.join("fixtures").join("linux-syscall-adv");
    let src = src_dir.join("main.c");
    let lib = src_dir.join("libsyscall.c");
    if !src.exists() {
        return Err(io::Error::new(
            io::ErrorKind::NotFound,
            "linux-syscall-adv fixture missing",
        ));
    }

    if !needs_rebuild_multi(&[&src, &lib], &out_path)? {
        return Ok(out_path);
    }

    build_linux_syscall_elf(&[&src, &lib], &out_path)?;

    Ok(out_path)
}

pub fn ensure_linux_syscall_child_elf(out_dir: &Path) -> io::Result<PathBuf> {
    fs::create_dir_all(out_dir)?;
    let out_path = out_dir.join("linux-syscall-child.elf");

    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let src_dir = manifest_dir.join("fixtures").join("linux-syscall-child");
    let src = src_dir.join("main.c");
    let lib = src_dir.join("libsyscall.c");
    if !src.exists() {
        return Err(io::Error::new(
            io::ErrorKind::NotFound,
            "linux-syscall-child fixture missing",
        ));
    }

    if !needs_rebuild_multi(&[&src, &lib], &out_path)? {
        return Ok(out_path);
    }

    build_linux_syscall_elf(&[&src, &lib], &out_path)?;

    Ok(out_path)
}

pub fn ensure_linux_page_fault_elf(out_dir: &Path) -> io::Result<PathBuf> {
    fs::create_dir_all(out_dir)?;
    let out_path = out_dir.join("linux-page-fault.elf");

    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let src_dir = manifest_dir.join("fixtures").join("linux-page-fault");
    let src = src_dir.join("main.c");
    if !src.exists() {
        return Err(io::Error::new(
            io::ErrorKind::NotFound,
            "linux-page-fault fixture missing",
        ));
    }

    if !needs_rebuild_multi(&[&src], &out_path)? {
        return Ok(out_path);
    }

    build_linux_syscall_elf(&[&src], &out_path)?;

    Ok(out_path)
}

pub fn run_linux_syscall_host_test(out_dir: &Path) -> io::Result<()> {
    let elf = ensure_linux_syscall_elf(out_dir)?;
    let test_dir = out_dir.join("host-test");
    fs::create_dir_all(&test_dir)?;
    fs::write(test_dir.join("msg.txt"), b"FILE\n")?;

    let mut child = Command::new(&elf)
        .current_dir(&test_dir)
        .stdin(std::process::Stdio::piped())
        .stdout(std::process::Stdio::piped())
        .stderr(std::process::Stdio::inherit())
        .spawn()?;

    if let Some(stdin) = child.stdin.as_mut() {
        stdin.write_all(b"IN\n")?;
    }

    let output = child.wait_with_output()?;
    if !output.status.success() {
        return Err(io::Error::other(format!(
            "linux-syscall host test failed: {output:?}"
        )));
    }
    if output.stdout != b"IN\nFILE\n" {
        return Err(io::Error::other(format!(
            "linux-syscall stdout mismatch: {:?}",
            output.stdout
        )));
    }

    Ok(())
}

fn needs_rebuild_multi(srcs: &[&Path], out: &Path) -> io::Result<bool> {
    if !out.exists() {
        return Ok(true);
    }
    let out_time = file_mtime(out)?;
    for src in srcs {
        let src_time = file_mtime(src)?;
        if src_time > out_time {
            return Ok(true);
        }
    }
    Ok(false)
}

fn file_mtime(path: &Path) -> io::Result<SystemTime> {
    fs::metadata(path)?.modified()
}

fn build_linux_syscall_elf(srcs: &[&Path], out_path: &Path) -> io::Result<()> {
    let tmp = out_path.with_extension("tmp");
    // Dependencies: a host C toolchain (`cc`/`gcc`/`clang`) with static linking support.
    let mut cmd = Command::new("cc");
    cmd.args([
        "-nostdlib",
        "-static",
        "-fno-pie",
        "-no-pie",
        "-fno-stack-protector",
        "-fno-asynchronous-unwind-tables",
        "-fno-unwind-tables",
        "-Wl,-e,_start",
        "-Wl,--build-id=none",
        "-o",
    ])
    .arg(&tmp);
    for src in srcs {
        cmd.arg(src);
    }

    run_checked(&mut cmd, "cc linux-syscall")?;
    fs::rename(tmp, out_path)?;
    Ok(())
}

fn write_if_missing(path: &Path, generator: fn() -> Vec<u8>) -> io::Result<()> {
    if path.exists() {
        return Ok(());
    }
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)?;
    }
    let tmp = path.with_extension("tmp");
    fs::write(&tmp, generator())?;
    fs::rename(&tmp, path)?;
    Ok(())
}

fn build_sample_with_links_tar() -> Vec<u8> {
    let mut tar = TarBuilder::new();
    tar.append_file(
        "original.txt",
        b"Hello, World!\nThis is a sample file.\n",
        0o644,
    )
    .expect("append original.txt");
    tar.append_hardlink("hardlink.txt", "original.txt")
        .expect("append hardlink.txt");
    tar.append_dir("documents", 0o755)
        .expect("append documents/");
    tar.append_file("documents/readme.txt", b"Sample document content.\n", 0o644)
        .expect("append documents/readme.txt");
    tar.append_symlink("link_to_readme", "documents/readme.txt")
        .expect("append link_to_readme");
    tar.append_symlink("link_to_docs", "documents")
        .expect("append link_to_docs");
    tar.append_symlink("documents/abs_link", "/abs_target.txt")
        .expect("append documents/abs_link");
    tar.append_file("abs_target.txt", b"test\n", 0o644)
        .expect("append abs_target.txt");
    tar.append_dir("data", 0o755).expect("append data/");
    tar.append_hardlink("data/hardlink_to_original.txt", "original.txt")
        .expect("append data/hardlink_to_original.txt");
    tar.finish()
}

/// Build `busybox.tar` by pulling and unpacking the OCI image.
///
/// # Dependencies
/// - `skopeo` (pulls `docker://busybox:musl` into an OCI layout)
/// - `umoci` (unpacks the OCI layout into a bundle directory)
/// - Network access to fetch the image
fn build_busybox_tar_from_oci(out_dir: &Path, busybox_tar: &Path) -> io::Result<()> {
    let oci_dir = out_dir.join("oci");
    let bundle_dir = out_dir.join("bundle");

    let _ = fs::remove_dir_all(&oci_dir);
    let _ = fs::remove_dir_all(&bundle_dir);

    let oci_ref = format!("oci:{}:{}", oci_dir.display(), OCI_TAG);
    run_checked(
        Command::new("skopeo").args(["copy", OCI_IMAGE, &oci_ref]),
        "skopeo copy",
    )?;

    let umoci_ref = format!("{}:{}", oci_dir.display(), OCI_TAG);
    run_checked(
        Command::new("umoci").args([
            "unpack",
            "--rootless",
            "--image",
            &umoci_ref,
            bundle_dir
                .to_str()
                .ok_or_else(|| io::Error::new(io::ErrorKind::InvalidInput, "bundle path"))?,
        ]),
        "umoci unpack",
    )?;

    let _ = fs::remove_file(bundle_dir.join("umoci.json"));
    if let Ok(entries) = fs::read_dir(&bundle_dir) {
        for entry in entries.flatten() {
            let name = entry.file_name();
            let Some(name) = name.to_str() else {
                continue;
            };
            if name.starts_with("sha256_") && name.ends_with(".mtree") {
                let _ = fs::remove_file(entry.path());
            }
        }
    }

    build_tar_from_dir(&bundle_dir, busybox_tar)?;

    let _ = fs::remove_dir_all(&oci_dir);
    let _ = fs::remove_dir_all(&bundle_dir);

    Ok(())
}

fn build_tar_from_dir(root: &Path, out_tar: &Path) -> io::Result<()> {
    let tmp = out_tar.with_extension("tmp");
    let file = File::create(&tmp)?;
    let mut writer = TarWriter::new(file);
    let mut hardlinks = HardlinkTracker::new();
    write_dir_entries(root, "", &mut writer, &mut hardlinks)?;
    writer.finish()?;
    fs::rename(tmp, out_tar)?;
    Ok(())
}

fn write_dir_entries(
    root: &Path,
    rel: &str,
    writer: &mut TarWriter<File>,
    hardlinks: &mut HardlinkTracker,
) -> io::Result<()> {
    let dir = if rel.is_empty() {
        root.to_path_buf()
    } else {
        root.join(rel)
    };

    let mut entries: Vec<_> = fs::read_dir(&dir)?.collect();
    entries.sort_by_key(|entry| {
        entry
            .as_ref()
            .ok()
            .and_then(|e| e.file_name().to_str().map(|s| s.to_string()))
    });

    for entry in entries {
        let entry = entry?;
        let file_name = entry.file_name();
        let Some(name) = file_name.to_str() else {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                "non-utf8 filename",
            ));
        };
        let rel_path = if rel.is_empty() {
            name.to_string()
        } else {
            format!("{rel}/{name}")
        };

        let meta = fs::symlink_metadata(entry.path())?;
        if meta.is_dir() {
            let mode = unix_mode(&meta, 0o755);
            writer.append_dir(&rel_path, mode)?;
            write_dir_entries(root, &rel_path, writer, hardlinks)?;
            continue;
        }

        if meta.file_type().is_symlink() {
            let target = fs::read_link(entry.path())?;
            let target = target
                .to_str()
                .ok_or_else(|| io::Error::new(io::ErrorKind::InvalidData, "non-utf8 symlink"))?;
            writer.append_symlink(&rel_path, target)?;
            continue;
        }

        if !meta.is_file() {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!("unsupported file type: {}", entry.path().display()),
            ));
        }

        if let Some(link_target) = hardlinks.remember(&meta, &rel_path) {
            writer.append_hardlink(&rel_path, &link_target)?;
            continue;
        }

        let mode = unix_mode(&meta, 0o644);
        writer.append_file_from_path(&rel_path, &entry.path(), mode, meta.len())?;
    }

    Ok(())
}

fn unix_mode(meta: &fs::Metadata, _fallback: u32) -> u32 {
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        meta.permissions().mode() & 0o777
    }
    #[cfg(not(unix))]
    {
        let _ = meta;
        fallback
    }
}

struct HardlinkTracker {
    #[cfg(unix)]
    seen: HashMap<(u64, u64), String>,
}

impl HardlinkTracker {
    fn new() -> Self {
        Self {
            #[cfg(unix)]
            seen: HashMap::new(),
        }
    }

    fn remember(&mut self, meta: &fs::Metadata, path: &str) -> Option<String> {
        #[cfg(unix)]
        {
            use std::os::unix::fs::MetadataExt;
            let key = (meta.dev(), meta.ino());
            if let Some(existing) = self.seen.get(&key) {
                return Some(existing.clone());
            }
            self.seen.insert(key, path.to_string());
            None
        }
        #[cfg(not(unix))]
        {
            let _ = meta;
            let _ = path;
            None
        }
    }
}

fn run_checked(cmd: &mut Command, label: &str) -> io::Result<()> {
    let status = cmd.status()?;
    if status.success() {
        Ok(())
    } else {
        Err(io::Error::other(format!("{label} failed with {status}")))
    }
}

struct TarWriter<W: Write> {
    out: W,
}

impl<W: Write> TarWriter<W> {
    fn new(out: W) -> Self {
        Self { out }
    }

    fn append_file_from_path(
        &mut self,
        path: &str,
        host: &Path,
        mode: u32,
        size: u64,
    ) -> io::Result<()> {
        self.append_header(path, size, mode, EntryKind::File, None)?;
        let mut file = File::open(host)?;
        let mut buffer = [0u8; 8192];
        let mut remaining = size;
        while remaining > 0 {
            let read_len = buffer.len().min(remaining as usize);
            let read = file.read(&mut buffer[..read_len])?;
            if read == 0 {
                break;
            }
            self.out.write_all(&buffer[..read])?;
            remaining = remaining.saturating_sub(read as u64);
        }
        self.pad_to_block(size as usize)
    }

    fn append_dir(&mut self, path: &str, mode: u32) -> io::Result<()> {
        let mut name = path.to_string();
        if !name.ends_with('/') {
            name.push('/');
        }
        self.append_header(&name, 0, mode, EntryKind::Directory, None)
    }

    fn append_symlink(&mut self, path: &str, target: &str) -> io::Result<()> {
        self.append_header(path, 0, 0o777, EntryKind::Symlink, Some(target))
    }

    fn append_hardlink(&mut self, path: &str, target: &str) -> io::Result<()> {
        self.append_header(path, 0, 0o644, EntryKind::Hardlink, Some(target))
    }

    fn finish(&mut self) -> io::Result<()> {
        self.out.write_all(&[0u8; 1024])
    }

    fn append_header(
        &mut self,
        path: &str,
        size: u64,
        mode: u32,
        kind: EntryKind,
        link: Option<&str>,
    ) -> io::Result<()> {
        let mut header = [0u8; 512];
        write_name_and_prefix(&mut header, path)?;
        write_octal(&mut header[100..108], u64::from(mode))?;
        write_octal(&mut header[108..116], 0)?;
        write_octal(&mut header[116..124], 0)?;
        write_octal(&mut header[124..136], size)?;
        write_octal(&mut header[136..148], 0)?;
        header[156] = kind.typeflag();
        if let Some(target) = link {
            write_field(&mut header[157..257], target)?;
        }
        header[257..263].copy_from_slice(b"ustar\0");
        header[263..265].copy_from_slice(b"00");
        write_checksum(&mut header)?;
        self.out.write_all(&header)
    }

    fn pad_to_block(&mut self, size: usize) -> io::Result<()> {
        let padding = padding_len(size);
        if padding > 0 {
            let zeros = vec![0u8; padding];
            self.out.write_all(&zeros)?;
        }
        Ok(())
    }
}

struct TarBuilder {
    data: Vec<u8>,
}

impl TarBuilder {
    fn new() -> Self {
        Self { data: Vec::new() }
    }

    fn append_file(&mut self, path: &str, data: &[u8], mode: u32) -> io::Result<()> {
        self.append_entry(path, data, mode, EntryKind::File)
    }

    fn append_dir(&mut self, path: &str, mode: u32) -> io::Result<()> {
        let mut name = path.to_string();
        if !name.ends_with('/') {
            name.push('/');
        }
        self.append_entry(&name, &[], mode, EntryKind::Directory)
    }

    fn append_symlink(&mut self, path: &str, target: &str) -> io::Result<()> {
        self.append_link(path, target, EntryKind::Symlink)
    }

    fn append_hardlink(&mut self, path: &str, target: &str) -> io::Result<()> {
        self.append_link(path, target, EntryKind::Hardlink)
    }

    fn append_link(&mut self, path: &str, target: &str, kind: EntryKind) -> io::Result<()> {
        self.append_entry_with_link(path, &[], 0o644, kind, Some(target))
    }

    fn append_entry(
        &mut self,
        path: &str,
        data: &[u8],
        mode: u32,
        kind: EntryKind,
    ) -> io::Result<()> {
        self.append_entry_with_link(path, data, mode, kind, None)
    }

    fn append_entry_with_link(
        &mut self,
        path: &str,
        data: &[u8],
        mode: u32,
        kind: EntryKind,
        link: Option<&str>,
    ) -> io::Result<()> {
        let mut header = [0u8; 512];
        write_name_and_prefix(&mut header, path)?;
        write_octal(&mut header[100..108], u64::from(mode))?;
        write_octal(&mut header[108..116], 0)?;
        write_octal(&mut header[116..124], 0)?;
        write_octal(&mut header[124..136], data.len() as u64)?;
        write_octal(&mut header[136..148], 0)?;
        header[156] = kind.typeflag();
        if let Some(target) = link {
            write_field(&mut header[157..257], target)?;
        }
        header[257..263].copy_from_slice(b"ustar\0");
        header[263..265].copy_from_slice(b"00");
        write_checksum(&mut header)?;

        self.data.extend_from_slice(&header);
        if !data.is_empty() {
            self.data.extend_from_slice(data);
            let padding = padding_len(data.len());
            if padding > 0 {
                self.data.resize(self.data.len() + padding, 0);
            }
        }
        Ok(())
    }

    fn finish(mut self) -> Vec<u8> {
        self.data.extend_from_slice(&[0u8; 1024]);
        self.data
    }
}

#[derive(Clone, Copy)]
enum EntryKind {
    File,
    Directory,
    Symlink,
    Hardlink,
}

impl EntryKind {
    fn typeflag(self) -> u8 {
        match self {
            EntryKind::File => b'0',
            EntryKind::Directory => b'5',
            EntryKind::Symlink => b'2',
            EntryKind::Hardlink => b'1',
        }
    }
}

fn write_name_and_prefix(header: &mut [u8; 512], path: &str) -> io::Result<()> {
    let trimmed = path.trim_start_matches('/');
    if trimmed.is_empty() {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "empty tar path",
        ));
    }
    let bytes = trimmed.as_bytes();
    if bytes.len() <= 100 {
        header[0..bytes.len()].copy_from_slice(bytes);
        return Ok(());
    }

    let mut split = None;
    for idx in (0..bytes.len()).rev() {
        if bytes[idx] == b'/' {
            let prefix_len = idx;
            let name_len = bytes.len() - idx - 1;
            if prefix_len <= 155 && name_len <= 100 {
                split = Some(idx);
                break;
            }
        }
    }

    let Some(idx) = split else {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "tar path too long",
        ));
    };

    let (prefix, name) = (&trimmed[..idx], &trimmed[idx + 1..]);
    header[0..name.len()].copy_from_slice(name.as_bytes());
    header[345..345 + prefix.len()].copy_from_slice(prefix.as_bytes());
    Ok(())
}

fn write_field(field: &mut [u8], value: &str) -> io::Result<()> {
    let bytes = value.as_bytes();
    if bytes.len() > field.len() {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "tar field too long",
        ));
    }
    field[..bytes.len()].copy_from_slice(bytes);
    Ok(())
}

fn write_octal(field: &mut [u8], value: u64) -> io::Result<()> {
    field.fill(b'0');
    let octal = format!("{:o}", value);
    if octal.len() + 1 > field.len() {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "octal field too small",
        ));
    }
    let start = field.len() - 1 - octal.len();
    field[start..start + octal.len()].copy_from_slice(octal.as_bytes());
    field[field.len() - 1] = 0;
    Ok(())
}

fn write_checksum(header: &mut [u8; 512]) -> io::Result<()> {
    for byte in &mut header[148..156] {
        *byte = b' ';
    }
    let mut sum: u32 = 0;
    for byte in header.iter() {
        sum = sum.wrapping_add(u32::from(*byte));
    }
    let field = &mut header[148..156];
    field.fill(b' ');
    let octal = format!("{:o}", sum);
    if octal.len() > 6 {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "checksum field too small",
        ));
    }
    let start = 6 - octal.len();
    field[start..start + octal.len()].copy_from_slice(octal.as_bytes());
    field[6] = 0;
    field[7] = b' ';
    Ok(())
}

fn padding_len(size: usize) -> usize {
    let rem = size % 512;
    if rem == 0 { 0 } else { 512 - rem }
}
